# ES 新特性与 TypeScript、JS 性能优化

## 一、请说出下列最终的执行结果，并解释为什么

```javascript
var a = []
for (var i = 0; i < 10; i++) {
	a[i] = function() {
		console.log(i)
	}
}
a[6]()
```

执行结果：10

原因：for 循环中的 i 使用 var 来定义所以 i 的作用域在全局，a 数组每次存入的函数中的 i 其实是全局作用域中的 i，而 i 在循环结束后值为 10，所以输出为 10

## 二、请说出下列最终的执行结果，并解释为什么

```js
var tmp = 123;

if (true) {
	console.log(tmp)
	let tmp
}
```

执行结果：无输出，会报错，报错内容为"Uncaught ReferenceError: Cannot access 'tmp' before initialization"

原因：if 语句块内输出的 tmp 是 let 声明的而不是全局的 var 声明的 tmp，而 let 不存在变量提升，在使用前必须先声明，所以输出时找不到 tmp

## 三、结合 ES6 新语法，用最简单的方式找出数组中的最小值

```js
var arr = [12, 34, 32, 89, 4]
```

解答：

```js
let arrMin = Math.min(...arr)
```



## 四、请详细说明 var, let, const 三种声明变量的方式之间的具体差别

|                            var                             |                             let                              |                            const                             |
| :--------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| 存在变量提升（可先使用，后声明）；作用域在全局或函数作用域 | 不存在变量提升（必须先声明后使用），作用域可以是全局、函数、块级作用域。同一作用域内不能重复声明 | 声明常量，必须赋初始值；不能修改（这里的不能修改指的是指向的内存地址） |



## 五、请说出下列代码最终输出的结果，并解释为什么

```js
var a = 10;
var obj = {
	a: 20,
	fn() {
		setTimeout(() => {
			console.log(this.a)
		})
	}
}
obj.fn()
```

执行结果：20

原因：箭头函数的 this 指向是其所属函数内部的 this。使用 Obj.fn() 调用时，this 指向是 obj ,所以 a 的值为 20

## 六、简述 Symbol 类型的用途

答：Symbol 表示独一无二的值。主要作用是为对象添加独一无二的属性名。

## 七、说说什么是浅拷贝，什么是深拷贝？

- 浅拷贝：只复制对象的第一层属性，对象里面的引用类型数据并不从重新开辟内存空间保存，所以当拷贝对象里面的引用类型有修改时，源对象也会改变。

  ```js
  var obj = {
  	a: 1,
  	b: {
  		c: 2
  	}
  }
  
  var newObj = Object.assign({}, obj); // 进行浅拷贝
  
  newObj.a = 7;
  newObj.b.c = 8;
  
  console.log(obj); // {a: 1, b: {c: 8}}
  console.log(newObj); // {a:7, b: {c: 8}}
  ```

- 深拷贝：复制源对象的所有属性包括对象里面的引用类型。对象里面的引用类型会新开辟内存空间保存，所以修改拷贝对象的引用类型时源对象不会改变

  ```js
  var obj = {
  	a: 1,
  	b: {
  		c: 2
  	}
  }
  
  var newObj = JSON.parse(JSON.stringfy(obj)); // 进行深拷贝
  
  newObj.a = 7;
  newObj.b.c = 8;
  
  console.log(obj); // {a: 1, b: {c: 2}}
  console.log(newObj); // {a: 7, b: {c: 8}}
  ```

  注：JSON对象实现深拷贝时无法拷贝对象中的方法

## 八、请简述 TypeScript 与 JavaScript 之间的关系

答：TypeScript 是 JavaScript 的超级，它在 JS 的基础上扩展了新特性，拥有更强大的类型系统

## 九、请谈谈你所认为的 TypeScript 优缺点

- 优点：
  - 类型系统强大，在编译时就能发现类型错误，避免开发中的类型错误，提高代码可靠性
  - 对 ES6+  新特性的支持，编译可选择适用版本，提高兼容性
- 缺点:
  - 概念多，增加学习成本
  - 项目初期因为需要编写类型声明等，增加了开发成本

## 十、描述引用计数的工作原理和优缺点

工作原理：

- 维护一个引用计数器，用于记录对象被引用的次数
- 当引用关系改变时修改引用数字
- 当引用数字为 0 时，则判定为垃圾，立即回收

优点：

- 发现垃圾时立即回收
- 减少程序卡顿时间

缺点:

- 无法回收循环引用的对象
- 时间开销大

## 十一、描述标记整理算法的工作流程

标记整理法分为标记和清除两个阶段

- 遍历所有对象，找到活动对象并进行标记

- 进行整理，移动活动对象时的这些对象在内存地址上连续

- 遍历所有对象清除没有标记的对象

  

## 十二、描述 V8 中新生代存储区垃圾回收的流程

V8 采用分代回收的思想，内存分为新生代和老生代，针对不同对象采用不同算法

新生代储存区垃圾回收流程：

回收过程采用复制算法 + 标记整理

- 将新生代内存分为两个等大小的空间，使用空间为 From, 空闲空间为 To
- 将活动对象存储在 From 空间
- 当 From 空间使用到一定程度后触发 GC
- GC 在 From 空间进行标记整理，然后将整理后的对象拷贝至 To 空间
- From 与 To 交换空间完成释放

## 十三、描述增量标记算法在何时使用及工作原理

在 V8 老生代回收中使用。

增量标记算法和程序执行是交错执行的，不能同时工作。遍历对象时，先标记一部分，然后停止，程序继续运行，再进行遍历标记。一直循环这个过程，直到完成所有标记后再进行清除。

